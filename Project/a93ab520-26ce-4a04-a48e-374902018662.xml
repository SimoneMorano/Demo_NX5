<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//FB name: MC_Home1S&#xD;
&#xD;
//Revision: 1.08&#xD;
//Library: &#xD;
//Namespace: OMR_CH_PP_Pos&#xD;
//Autor: UN 28.11.16&#xD;
// Changes:  V1.07:  &#xD;
// Changes: V1.08:   ErrorID 1804 ErrorIDEx  0800 0021  during homing should be solved&#xD;
//								Rotation Direction of motor (3000.01) is considered, for home offset calculation&#xD;
//								Status.Homing flag corrected&#xD;
&#xD;
// Function: Home procedure using PP_Position FB. Homing is done with homing mode setup in 1s Parameter 3A00.02&#xD;
// Input/Output:&#xD;
//		AxisPar  -&gt; Axis structure of PP_Positioning&#xD;
// Input: &#xD;
//		Execute [BOOL]&#xD;
//		HomeOffset [DINT]  Offset applied after successful homing&#xD;
// Output:&#xD;
//		Done [BOOL]  finished successful activ only for one cycle&#xD;
//		Busy [BOOL]&#xD;
//		ErrorID [UINT] failure numbers of PP_Positioning are used.   16#FFFF -&gt; Axis was not switch on  | 16#5466 Instruction ExecutionError withUndefined Home  (switched of during homing)&#xD;
//		Error [BOOL]  error appeared&#xD;
&#xD;
// 3A00.02 Homing Method&#xD;
//		8 Homing by Home Proximity Input and home signal (positive operation start)&#xD;
//		12 Homing by Home Proximity Input and home signal (negative operation start)&#xD;
//		19 Homing without home signal (positive operation start) &#xD;
//		20 Homing without home signal (negative operation start)&#xD;
//		33 Homing with home signal (negative operation start)&#xD;
//		34 Homing with home signal (positive operation start)&#xD;
//		37 Present home preset&#xD;
// 3A00.03 Homing speed during search for switch&#xD;
// 3A00.04 Homing speed during search for zero&#xD;
// 3A00.05 Homing Acceleration&#xD;
// 3A00.06 Homing Offest  MUST BE SET TO 0 !&#xD;
&#xD;
&#xD;
CASE state OF&#xD;
	0:   //wait for execute&#xD;
		Done:=FALSE;&#xD;
&#xD;
		IF (Execute=TRUE)  THEN&#xD;
			Error:= FALSE;&#xD;
			FB_ECSDOReadMotRev.Execute:=FALSE;&#xD;
			FB_ECSDOReadOneRotation.Execute:=FALSE;&#xD;
			FB_ECSDOReadShaftRev.Execute:=FALSE;&#xD;
			FB_ECSDOReadHMmode.Execute:=FALSE;&#xD;
			FB_ECSDOReadOperSelect.Execute:=FALSE;&#xD;
			FB_ECSDOReadRotationDirection.Execute:=FALSE;  //V1.08&#xD;
			FB_ResetMultiturn.Execute:=FALSE;&#xD;
			FB_SwitchOffWaitTime.In:=FALSE;&#xD;
			FB_TONwait1Sready.In := FALSE;&#xD;
			FB_ECSDOWriteReset.Execute := FALSE;&#xD;
			ErrorID:=16#0;&#xD;
			Busy:=TRUE;&#xD;
			Axis.Details.Homed := FALSE;&#xD;
			Axis.ModeOfOperation := 6;   //Homing mode (HM)&#xD;
			Axis.ControlWord := Axis.ControlWord AND WORD#2#1111_1110_1110_1111;   //Reset Homing start Bit 4	and halt bit 8&#xD;
			state:= 5;&#xD;
		END_IF;&#xD;
	5:    //read out homing mode and Operation Selection Absolute Encoder&#xD;
		IF Axis.DrvStatus.ServoOn THEN&#xD;
			FB_ECSDOReadHMmode.Execute:=TRUE;&#xD;
			FB_ECSDOReadOperSelect.Execute:=TRUE;&#xD;
			state:=10;&#xD;
		ELSE&#xD;
			ErrorID := 16#FFFF;    //Axis is switch off !&#xD;
			state := 10005;&#xD;
		END_IF;&#xD;
&#xD;
	&#xD;
	10:  //Read Homing mode set in 1S Parameter&#xD;
		IF FB_ECSDOReadHMmode.ReadSize&gt;0 AND FB_ECSDOReadOperSelect.ReadSize&gt;0 THEN&#xD;
			FB_ECSDOReadHMmode.Execute:=FALSE;&#xD;
			FB_ECSDOReadOperSelect.Execute := FALSE;&#xD;
			IF ReadDataHM = 0 OR ReadDataHM = 37 THEN      //home present position, just do a "SET Position"&#xD;
				state := 1000;&#xD;
			ELSE  //8,12,19,20,33,34   Homing procedere with movement&#xD;
				state := 30;&#xD;
			END_IF;&#xD;
		ELSIF FB_ECSDOReadHMmode.Error OR FB_ECSDOReadOperSelect.Error THEN&#xD;
			FB_ECSDOReadHMmode.Execute:=FALSE;&#xD;
			FB_ECSDOReadOperSelect.Execute:=FALSE;&#xD;
			ErrorID := FB_ECSDOReadHMmode.ErrorID;&#xD;
			state := 10010;&#xD;
		END_IF;&#xD;
	&#xD;
	30:   //wait mode of operation is HM    Start Homing&#xD;
		IF Axis.ModeOfOperationDisplay = 6 THEN&#xD;
			Axis.ControlWord := Axis.ControlWord OR WORD#2#0000_0000_0001_0000;   //Set Homing start Bit 4&#xD;
			Axis.Status.Homing := TRUE;&#xD;
			state := 100;&#xD;
		ELSIF    Axis.DrvStatus.DrvAlarm OR not Axis.DrvStatus.MainPower OR NOT Axis.DrvStatus.ServoOn THEN&#xD;
			state := 10030;&#xD;
		END_IF;&#xD;
		&#xD;
	100:   //wait home finshed&#xD;
		IF ((Axis.StatusWord AND WORD#2#0001_0100_0000_0000) = WORD#2#0000_0000_0000_0000) THEN &#xD;
			Axis.ControlWord := Axis.ControlWord AND WORD#2#1111_1111_1110_1111;   //Reset Homing start Bit 4	&#xD;
		ELSIF ((Axis.StatusWord AND WORD#2#0001_0100_0000_0000) = WORD#2#0001_0100_0000_0000) THEN   //Bit 10 Target reached and Bit 12 Homing attained&#xD;
			Axis.ControlWord := Axis.ControlWord AND WORD#2#1111_1111_1110_1111;   //Reset Homing start Bit 4	&#xD;
			IF ReadDataOperSelect = 1 THEN   // Use as Incremental Encoder is selected, clear of multiturn not necessary reboot not necessary&#xD;
				Axis.HomeOffset := HomeOffset;&#xD;
				Axis.Cmd.Pos := HomeOffset;&#xD;
				state := 500;&#xD;
			ELSE   // Use as Absolute encoder is selected, multiturn must be clear and reboot&#xD;
				state := 200;&#xD;
				Axis.Details.HomeInProgress := TRUE;  //V1.08  internal bit homing procedure started&#xD;
			END_IF;&#xD;
		ELSIF ((Axis.StatusWord AND WORD#2#0010_0000_0000_0000) = WORD#2#0010_0000_0000_0000)  OR (Axis.ModeOfOperation&lt;&gt;6) &#xD;
			 OR Axis.DrvStatus.DrvAlarm OR not Axis.DrvStatus.MainPower OR NOT Axis.DrvStatus.ServoOn THEN  //Bit 13 Homing Error &#xD;
			Busy := FALSE;&#xD;
			state := 10100;&#xD;
			Error := TRUE;&#xD;
			ErrorID := ERR_HOMING;						//16#5466;    Homing error&#xD;
		END_IF;&#xD;
&#xD;
	200:   //switch off  (to start clear of multiturn encoder)&#xD;
		Axis.ControlWord := (Axis.ControlWord AND WORD#2#0000_0000_0000_0000) OR WORD#2#0111; //xxxx_xxxx_xxxx_x111= Shutdown command&#xD;
		FB_SwitchOffWaitTime.In := TRUE;&#xD;
		state := 220;&#xD;
		&#xD;
	220:  //wait Servo is off and standstill&#xD;
		IF not Axis.DrvStatus.ServoOn AND FB_SwitchOffWaitTime.Q AND ((Axis.Act.VelRpm &lt; 25) AND (Axis.Act.VelRpm&gt; -25)) THEN&#xD;
				FB_SwitchOffWaitTime.In := FALSE;&#xD;
				ReadSizeOneRotation := 0;&#xD;
				ReadSizeShaftRev := 0;&#xD;
				ReadSizeMotRev := 0;&#xD;
				IF _EC_MBXSlavTbl[Axis.Cfg.NodeAddress] THEN  //V1.08&#xD;
					FB_ECSDOReadOneRotation.Execute:=TRUE;&#xD;
					FB_ECSDOReadMotRev.Execute:=TRUE;&#xD;
					FB_ECSDOReadShaftRev.Execute:=TRUE;&#xD;
					FB_ECSDOReadRotationDirection.Execute:=TRUE;  //V1.08&#xD;
				END_IF;&#xD;
			state := 230;&#xD;
		END_IF;&#xD;
		&#xD;
	230:   //Read auf Encoder date  One Rotation Position, Shaft Revolution, Motor revolution           Set  new Offset&#xD;
		IF ReadSizeOneRotation &gt; 0  AND ReadSizeShaftRev &gt; 0 AND ReadSizeMotRev&gt;0 AND ReadSizeRotationDirection&gt;0 THEN&#xD;
			corrOneTurn := (DINT_TO_LREAL(ReadDataOneRotation)*ReadDataShaftRev/ReadDataMotRev);&#xD;
			NewOffset := LREAL_TO_DINt(corrOneTurn);&#xD;
			IF  ReadDataRotationDirection  = 1 THEN   //V1.08    standard rotation direction  in 3000.01&#xD;
				Axis.HomeOffset := HomeOffset-NewOffset; //Reset HomeOffset of SetPos		&#xD;
			ELSE  //inverse rotation direction in 3000.01&#xD;
				Axis.HomeOffset := HomeOffset+NewOffset; //Reset HomeOffset of SetPos		&#xD;
			END_IF;				&#xD;
			FB_ECSDOReadOneRotation.Execute:=FALSE;&#xD;
			FB_ECSDOReadMotRev.Execute := FALSE;&#xD;
			FB_ECSDOReadShaftRev.Execute := FALSE;&#xD;
			FB_ECSDOReadRotationDirection.Execute:=FALSE;&#xD;
			IF _EC_MBXSlavTbl[Axis.Cfg.NodeAddress] THEN  //V1.08&#xD;
				FB_ResetMultiturn.Execute:=TRUE;		&#xD;
				state := 250;&#xD;
			END_IF;&#xD;
		ELSIF FB_ECSDOReadOneRotation.Error  OR FB_ECSDOReadShaftRev.Error OR FB_ECSDOReadMotRev.Error OR FB_ECSDOReadRotationDirection.Error THEN&#xD;
			IF FB_ECSDOReadOneRotation.Error THEN&#xD;
				ErrorID:=FB_ECSDOReadOneRotation.ErrorID;&#xD;
			ELSIF FB_ECSDOReadShaftRev.Error THEN&#xD;
				ErrorID:=FB_ECSDOReadShaftRev.ErrorID;&#xD;
			ELSIF FB_ECSDOReadMotRev.Error THEN&#xD;
				ErrorID:=FB_ECSDOReadMotRev.ErrorID;&#xD;
			END_IF;&#xD;
			FB_ECSDOReadOneRotation.Execute:=FALSE;&#xD;
			FB_ECSDOReadMotRev.Execute := FALSE;&#xD;
			FB_ECSDOReadShaftRev.Execute := FALSE;&#xD;
			FB_ECSDOReadRotationDirection.Execute:=FALSE;  //V1.08&#xD;
			state := 10230;&#xD;
		END_IF;&#xD;
		&#xD;
	&#xD;
	250:   //Wait until Multiturn counter is reset&#xD;
		IF FB_ResetMultiturn.Done THEN&#xD;
			FB_ResetMultiturn.Execute:=FALSE;&#xD;
			state := 400;&#xD;
			FB_SwitchOffWaitTime.In :=TRUE;&#xD;
		ELSIF FB_ResetMultiturn.Error THEN&#xD;
			ErrorID := FB_ResetMultiturn.ErrorID;&#xD;
			FB_ResetMultiturn.Execute:=FALSE;&#xD;
			state := 10250;&#xD;
		END_IF;&#xD;
&#xD;
	400: // Restart the drive&#xD;
		Axis.ModeOfOperation := 1;   //PP Mode&#xD;
		ClearString(InOut:=ResetDrive);&#xD;
		ResetDrive := 'tesera'; // Code to set for executing the Motor ID setup in the drive  16# 74 65 73 65 72 61&#xD;
&#xD;
		IF _EC_MBXSlavTbl[Axis.Cfg.NodeAddress] THEN  //V1.08&#xD;
			IF not Axis.DrvStatus.ServoOn AND FB_SwitchOffWaitTime.Q AND ((Axis.Act.VelRpm &lt; 25) AND (Axis.Act.VelRpm&gt; -25)) THEN	&#xD;
				FB_SwitchOffWaitTime.In := FALSE;&#xD;
				FB_ECSDOWriteReset.Execute := TRUE;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		&#xD;
		IF FB_ECSDOWriteReset.Done THEN&#xD;
			FB_ECSDOWriteReset.Execute :=FALSE;	&#xD;
			FB_TONwait1Sreset(In:=FALSE);&#xD;
			state := 430;&#xD;
		ELSIF FB_ECSDOWriteReset.Error THEN&#xD;
			ErrorID := FB_ECSDOWriteReset.ErrorID;&#xD;
			state := 10400;&#xD;
		END_IF;&#xD;
	430:  //wait until 1s is reboot&#xD;
		FB_TONwait1Sreset(In:=TRUE,PT:=T#5s00ms);&#xD;
		IF FB_TONwait1Sreset.Q THEN&#xD;
			FB_TONwait1Sreset.In := FALSE;&#xD;
			FB_ResetECError.Execute:=FALSE;&#xD;
			state := 450;&#xD;
		END_IF;&#xD;
	450: // Reset EC Error&#xD;
		FB_ResetECError.Execute := TRUE;&#xD;
		IF FB_ResetECError.Done THEN&#xD;
			FB_ResetECError.Execute:=FALSE;&#xD;
			FB_TONwait1Sready.In:=TRUE;&#xD;
			state := 460;&#xD;
		ELSIF FB_ResetECError.Error  THEN&#xD;
			FB_ResetECError.Execute:=FALSE;&#xD;
			ErrorID := FB_ResetECError.ErrorID;&#xD;
			state := 10450;&#xD;
		END_IF;&#xD;
	460: // wait until ready&#xD;
		IF FB_TONwait1Sready.Q THEN&#xD;
			FB_TONwait1Sready.In := FALSE;&#xD;
			state := 500;&#xD;
		END_IF;&#xD;
	500:  //finish&#xD;
			Axis.Details.Homed := TRUE;&#xD;
			Axis.Details.HomeInProgress := FALSE;  //V1.08  internal bit homing procedure started&#xD;
			Done :=TRUE;&#xD;
			Busy:= FALSE;&#xD;
			Axis.ModeOfOperation := 1;&#xD;
			state := 0;&#xD;
		&#xD;
	1000:  //Home preset    SET POSITION    that's all&#xD;
		Axis.HomeOffset := -((LREAL_TO_DINT(Axis.Act.Pos)-Axis.HomeOffset) - LREAL_TO_DINT(HomeOffset));		//Calculate new HomeOffset&#xD;
		Axis.Cmd.Pos := DINT_TO_LREAL(HomeOffset); //V1.07 02.10.2017  explicit convert from DINT to LREAL&#xD;
		Done:=TRUE;&#xD;
		Busy := FALSE;&#xD;
		state := 0;&#xD;
	&#xD;
	10000..20000:&#xD;
		Axis.Details.HomeInProgress := FALSE;  //V1.08  internal bit homing procedure started&#xD;
		Busy := FALSE;&#xD;
		Error:= TRUE;&#xD;
		IF ErrorID=0 THEN&#xD;
			ErrorID := UINT_TO_WORD(state);&#xD;
		END_IF;&#xD;
		Axis.ControlWord := Axis.ControlWord OR WORD#2#0000_0001_0000_0000;   //Set Bit 8 Halt&#xD;
		state := 0;&#xD;
END_CASE;&#xD;
&#xD;
//   instance calls&#xD;
FB_SwitchOffWaitTime(PT:=t#60ms);&#xD;
FB_ECSDOReadRotationDirection( NodeAdr:=Axis.Cfg.NodeAddress, SdoObj:=SDOObjectRotationDirection,ReadDat:=ReadDataRotationDirection, ReadSize=&gt;ReadSizeRotationDirection);  //V1.08&#xD;
FB_ECSDOReadOneRotation( NodeAdr:=Axis.Cfg.NodeAddress, SdoObj:=SDOObjectOneRotation,ReadDat:=ReadDataOneRotation, ReadSize=&gt;ReadSizeOneRotation);&#xD;
FB_ECSDOReadShaftRev( NodeAdr:=Axis.Cfg.NodeAddress, SdoObj:=SDOObjectShaftRev, ReadDat:=ReadDataShaftRev, ReadSize=&gt;ReadSizeShaftRev);&#xD;
FB_ECSDOReadMotRev( NodeAdr:=Axis.Cfg.NodeAddress, SdoObj:=SDOObjectMotRev, ReadDat:=ReadDataMotRev, ReadSize=&gt;ReadSizeMotRev);&#xD;
FB_ECSDOReadHMmode(NodeAdr:=Axis.Cfg.NodeAddress, SDOObj:=SDOObjecHMmode, ReadDat:=ReadDataHM,ReadSize=&gt;ReadSizeHMmode);&#xD;
FB_ECSDOReadOperSelect(NodeAdr:=Axis.Cfg.NodeAddress,SDOObj:=SDOObjectOperSelection,ReadDat:=ReadDataOperSelect,ReadSize=&gt;ReadSizeOperSelect);&#xD;
&#xD;
FB_ResetMultiturn(NodeAdr:=Axis.Cfg.NodeAddress,TimeOut:=100);&#xD;
FB_ECSDOWriteReset(NodeAdr:=Axis.Cfg.NodeAddress, SdoObj:=SDOObjectReboot, WriteDat:=ResetDrive, WriteSize:=6);&#xD;
&#xD;
FB_TONwait1Sready(PT:=T#3s20ms);  //V1.08&#xD;
&#xD;
&#xD;
FB_ResetECError();</Text></StructuredTextModel>